1. 题目一:

  ```bash
    把一个二维数组展开为一个一维数组;
    let arrs = [[1,2,3,4],[5,6,7,8]]; 
    展开为[1,2,3,4,5,6,7,8];
  ```

  题目二:

  ```bash
      *
        多维数组降维度
        let arrs = [1,[1],[1,[1,2,3,[4,5,6]]]]; 
        展开为 [1,1,1,1,2,3,4,5,6];
      * 
      [1,[1],[1,[1,2,3,[4,5,6]]]].flat(Infinity);
  ```

2. 数据结构:

   - 数组  ( 队列，栈，矩阵 )。
   - 集合  字典和散列表。
   - 树    树是一种分层数据的抽象模型。 
   - 图
   - 链表

3. 常见的排序算法:

   ```冒泡排序：```  拿当前值跟后面的值挨个比较 如果当前值比后面的值大 就替换位置。

   ```选择排序：```  每次找到数组中最小的值的索引 跟当前索引位置元素交换。

   ``` 插入排序：``` 把当前索引的值当作一个基准 拿前一个值跟这个值对比 如果比他大就替换他的位置 最后把它插入到自己该在的位置。排序小型数组时，此算法比选择排序和冒泡排序性能要好。

   ```归并排序：``` 把数组先剁两半 然后各自排序 不断递归这个过程 最后把两大半数组排序，其复杂度跟快排一样 为O(nlogn) logn的意思是以2为底n的对数 说白了就是2的几次方等于n。 
   ```快排:```     快排的复杂度和归并排序一样为O(nlogn) 一指针两拨片 1.首先，从数组中选择中间一项作为主元。 2.创建两个指针，左边一个指向数组第一个项，右边一个指向数组最后一个项。然后移动左右指针，左找大，右找小，交换位置 重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之 前，而比主元大的值都排在主元之后。这一步叫作划分操作 3.接着，算法对划分后的小数组(较主元小的值组成的子数组，以及较主元大的值组成的 子数组)重复之前的两个步骤，直至数组已完全排序。 
   
   ```二分搜索:```  (1) 选择数组的中间值。 
                   (2) 如果选中值是待搜索值，那么算法执行完毕(值找到了)。 (3) 如果待搜索值比选中值要小，则返回步骤1并在选中值左边的子数组中寻找。 
                   (4) 如果待搜索值比选中值要大，则返回步骤1并在选种值右边的子数组中寻找。
4. 动态规划:
   
   ```bash
    背包问题:
    最长公共子序列:
    矩阵链相乘:
   ```





   
   
